\documentclass[10pt,pdf,hyperref={unicode},aspectratio=1610]{beamer}

% \documentclass[aspectratio=43]{beamer}
% \documentclass[aspectratio=1610]{beamer}
% \documentclass[aspectratio=169]{beamer}

% подключаем для описания алгоритмов
\usepackage{algorithm}
%\usepackage{algorithmic}
%\usepackage{algorithmicx}
\usepackage{algpseudocode}

% подключаем кириллицу 
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}

% Выбираем основную тему
%\usetheme{Berlin} 
\usetheme{Copenhagen}
%\usetheme{Hannover}

% Дополнительно подключаем шрифты
\usefonttheme{serif} 
% Авторы
\author{Баркалов~К.А.}
% Название презентации
\title{Распределенные алгоритмы}
\subtitle{Введение}
% Организации
\institute{Кафедра МОСТ института ИТММ \\ ННГУ им. Н.И. Лобачевского }
% Дата (команда \today выводит текущую дату)
\date{Нижний Новгород, 2020}
% \logo{\includegraphics[height=5mm]{images/logo.png}\vspace{-7pt}}

% Определяем необходимые окружения
\newtheorem{mydef}{Определение}
\newtheorem{mylem}{Лемма}

%\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%


% отключить клавиши навигации
\setbeamertemplate{navigation symbols}{}


\begin{document}
% Титульная страница
\frame{\titlepage}

% Содержание презентации (выводятся только основные разделы)
\frame{\tableofcontents}%[hideallsubsections]}
% Разбиение текста на разделы
% Отображаются в содержании, но не в презентации
%\chapter{Метрические пространства}
%\section{Функциональная зависимость. Пространство. Упорядоченность}
\section{Введение}
\subsection{Распределенные системы}
\begin{frame}{Распределенные системы}

Зачем нужны распределенные системы?
\begin{itemize}
\item Обмен информацией 
\item Совместное использование ресурсов 
\item Повышение надежности (дублирование)
\item Повышение производительности (параллельное выполение)
\item Упрощение проектирования (специализация)
\end{itemize}

\end{frame}


\begin{frame}{Основные понятия}
\begin{mydef} %[процесс]
\textbf{Распределенная система} состоит из набора \textbf{процессов} $\Pi = \{p_1,...,p_n\}$.  
Процессы взаимодействуют между собой для достижения общей цели.
Каждый процесс $p_i$ знает свой идентификатор $id_i$; обычно  $id_i = i$. 
У каждого процесса $p_i$ есть множество соседних процессов $neighbors_i$.
\end{mydef}

\begin{mydef} %[процесс]
Процессы взаимодействуют, отправляя и получая \textbf{сообщения} по \textbf{каналам связи}. 
\end{mydef}
Будем предполагать, что каналы связи:
\begin{itemize}
\item first in first out (FIFO) --- сообщения принимаются в порядке их отправления; 
\item двунаправленные (можно и отправлять, и получать сообщения);
\item пропускная способность не ограничена (можно отсылать любое число сообщений любого размера);
\item в особых случаях каналы --- однонаправленные (только прием или отправка).
\end{itemize}


\end{frame}

\begin{frame}{Основные понятия}

Распределенная система может быть представлена связным неориентированным графом $G=(\Pi,C)$, где $\Pi$ --- множество процессов, $C$ --- множество каналов связи.

\begin{figure}
\begin{minipage}{0.2\linewidth}
\center{\includegraphics[width=1.0\linewidth]{ring_1.png}\\ \textit{кольцо}}
\end{minipage}
\begin{minipage}{0.2\linewidth}
\center{\includegraphics[width=1.0\linewidth]{tree_1.png}\\ \textit{дерево}}
\end{minipage}
\begin{minipage}{0.2\linewidth}
\center{\includegraphics[width=1.0\linewidth]{clique_1.png}\\ \textit{клика}}
\end{minipage}
\caption{Три типа графов, представляющих особый интерес}
\label{fig_graphs}
\end{figure}

\end{frame}

\subsection{Распределенные алгоритмы}
\begin{frame}{Основные понятия}
\begin{mydef} 
\textbf{Распределенный алгоритм} --- набор из $n$ автоматов, по одному на процесс. Автомат описывает последовательность шагов, выполняемых соответствующим процессом и содержит две особых операции --- send () и receive (), которые позволяют ему отправлять и получать сообщения.
\end{mydef}

Распределенный \textit{синхронный} алгоритм: каждый шаг алгоритма соответствует одному такту внешних \textit{глобальных часов}.

Распределенный \textit{асинхронный} алгоритм: доступа к глобальным часам нет, выполнение процесса зависит от собственных вычислений и полученных сообщений.

\end{frame}


\subsection{Пример распределенного алгоритма}

\begin{frame}{Пример распределенного алгоритма}

\begin{algorithm}[H]
\caption{Название алгоритма}
\begin{algorithmic}

\ForAll {$id_j \in neighbors_i$} 
	\State{send Position($id_i,neighbors_i$) to the neighbor $id_j$} 
\EndFor
\State{$part_i \gets true$}
end operation.
when START() is received do
\State{
	\If {$part_i$}	\State {START()}	\EndIf	
}
\end{algorithmic}
\end{algorithm}
\end{frame}


\end{document}